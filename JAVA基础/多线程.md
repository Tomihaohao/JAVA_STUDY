# 多线程
- 减少上下文切换

    无锁并发编程，CAS算法，使用最少的线程，使用协程
- 死锁

    线程互相等待对方释放锁
- volatile

    volatile 是轻量级别的synchronized
- synchronized

    - 对于普通同步方法，锁是当前的实例对象
    - 对于静态同步方法，锁是当前类class
    - 对于同步方法块，锁是括号里配置的对象

- 偏向锁，轻量级锁，重量级锁

## JVM内存基础

JAVA 采用的是共享内存模型，通信总是隐式的

JMM（JAVA内存模型）定义了线程和主内存之间的抽象关系，线程之间的共享变量存储在主内存当中，每一个线程都有自己私有的本地内存，本地内存存储了共享变量的副本

## volatile

当读取一个volatile变量时，JMM会把该线程对应的本地内置内存设置为无效，线程接下来将从主内存中读取共享变量

## 线程的状态

- NEW 初始状态，线程构建，但是还没有调用start()方法
- RUNABLE 运行状态，java线程将操作系统中的就绪和运行两种状态 都称作为运行中
- BLOCKED 阻塞状态
- WAITING 等待状态，表示线程进入等待状态，进入该状态表示当前线程等待其他线程做出一些特定的动作
- TIME_WAITING 超时等待状态，它可以在指定的时间自动返回但是WAITING不行
- TERMMINATED 终止状态，表示当前线程已经执行完毕

## 理解中断
- isInterrupted 判断是否中断 
- Thread.interrupted 对中断标识进行复位
- InterruptedException JVM会首先清除标识位然后在抛出异常
- 暂停 恢复 停止-》 suspend() resume() stop() 不建议使用 stop()不能安全的终止线程

## 安全的终止线程
```java
public class shutdown{
    public static void main(String[] args) throws Exception {
        Runner one = new Runner();
        Thread countThread = new Thread(one,"CounThread");
        countThread.start();
        TimeUnit.SECONDS.sleep(1);
        countThread.interrupt(); //中断

        Runner two = new Runner();
        countThread = new Thread(two,"CountThread");
        countThread.start();
        TimeUnit.SECONDS.sleep(1);
        two.cancel();// 取消
    }
}
```

## 线程间的通信
可以通过volatile 进行通信

也可以通过synchronized 关键字 锁定同步块

任意线程对Object (Object 由 synchronized保护) 的访问，首先要获得Object的监视器，如果获取失败，线程进入同步队列，线程状态变为BLOCKED ,当访问Object的前驱（获得了锁的线程）释放了锁，则该释放操作唤醒阻塞在同步队列中的线程，使其重新尝试对监视器的获取

## 等待通知
- notify() 通知一个在对象上等待的线程，使其从wait()方法返回 返回的前提是获得了锁
- notifyAll() 通知所有等待在该对象上的线程
- wait() 调用该方法的线程进入WAITING状态，同时释放对象的锁
- wait(long) 超时等待一段时间
- wait(long,int)

一个线程A调用了对象O的wait()方法进入等待状态，而另外一个线程B调用了对象的notify()或者notifyAll()方法，线程A收到通知后从对象O的wait()方法返回

### Thread.join() 就是等待通知的应用
### ThreadLocal
线程变量： 是一个以ThreadLocal对象为键，任意对象为值的存储结构，这个结构被附带在线程上面，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。

通过SET()设置，通过GET()获取

## 线程池技术

简单的线程池接口
```java
public interface ThreadPool<Job extends Runnable>{
    //执行一个JOB
    void execute(Job job);
    //关闭线程池
    void shutdown();
    //增加工作线程
    void addWorkers(int num)
    //减少工作线程
    void removeWorkers(int num)
    //得到正在等待的任务数量
    int getJobSize();
}
```