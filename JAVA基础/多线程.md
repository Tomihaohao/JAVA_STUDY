# 多线程
- 减少上下文切换

    无锁并发编程，CAS算法，使用最少的线程，使用协程
- 死锁

    线程互相等待对方释放锁
- volatile

    volatile 是轻量级别的synchronized
- synchronized

    - 对于普通同步方法，锁是当前的实例对象
    - 对于静态同步方法，锁是当前类class
    - 对于同步方法块，锁是括号里配置的对象

- 偏向锁，轻量级锁，重量级锁

## JVM内存基础

JAVA 采用的是共享内存模型，通信总是隐式的

JMM（JAVA内存模型）定义了线程和主内存之间的抽象关系，线程之间的共享变量存储在主内存当中，每一个线程都有自己私有的本地内存，本地内存存储了共享变量的副本

## volatile

当读取一个volatile变量时，JMM会把该线程对应的本地内置内存设置为无效，线程接下来将从主内存中读取共享变量

## 线程的状态

- NEW 初始状态，线程构建，但是还没有调用start()方法
- RUNABLE 运行状态，java线程将操作系统中的就绪和运行两种状态 都称作为运行中
- BLOCKED 阻塞状态
- WAITING 等待状态，表示线程进入等待状态，进入该状态表示当前线程等待其他线程做出一些特定的动作
- TIME_WAITING 超时等待状态，它可以在指定的时间自动返回但是WAITING不行
- TERMMINATED 终止状态，表示当前线程已经执行完毕

## 理解中断
- isInterrupted 判断是否中断 
- Thread.interrupted 对中断标识进行复位
- InterruptedException JVM会首先清除标识位然后在抛出异常
- 暂停 恢复 停止-》 suspend() resume() stop() 不建议使用 stop()不能安全的终止线程

## 安全的终止线程
```java
public class shutdown{
    public static void main(String[] args) throws Exception {
        Runner one = new Runner();
        Thread countThread = new Thread(one,"CounThread");
        countThread.start();
        TimeUnit.SECONDS.sleep(1);
        countThread.interrupt(); //中断

        Runner two = new Runner();
        countThread = new Thread(two,"CountThread");
        countThread.start();
        TimeUnit.SECONDS.sleep(1);
        two.cancel();// 取消
    }
}
```

## 线程间的通信
可以通过volatile 进行通信

也可以通过synchronized 关键字 锁定同步块

任意线程对Object (Object 由 synchronized保护) 的访问，首先要获得Object的监视器，如果获取失败，线程进入同步队列，线程状态变为BLOCKED ,当访问Object的前驱（获得了锁的线程）释放了锁，则该释放操作唤醒阻塞在同步队列中的线程，使其重新尝试对监视器的获取

## 等待通知
- notify() 通知一个在对象上等待的线程，使其从wait()方法返回 返回的前提是获得了锁
- notifyAll() 通知所有等待在该对象上的线程
- wait() 调用该方法的线程进入WAITING状态，同时释放对象的锁
- wait(long) 超时等待一段时间
- wait(long,int)

一个线程A调用了对象O的wait()方法进入等待状态，而另外一个线程B调用了对象的notify()或者notifyAll()方法，线程A收到通知后从对象O的wait()方法返回

### Thread.join() 就是等待通知的应用
### ThreadLocal
线程变量： 是一个以ThreadLocal对象为键，任意对象为值的存储结构，这个结构被附带在线程上面，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。

通过SET()设置，通过GET()获取

## 线程池技术

简单的线程池接口
```java
public interface ThreadPool<Job extends Runnable>{
    //执行一个JOB
    void execute(Job job);
    //关闭线程池
    void shutdown();
    //增加工作线程
    void addWorkers(int num)
    //减少工作线程
    void removeWorkers(int num)
    //得到正在等待的任务数量
    int getJobSize();
}
```
## lock
lock 特性：
- 尝试非阻塞的获取锁
- 能够被中断的获取锁
- 超时的获取锁

API:
- void lock() 获取锁
- void lockInterruptibly() 可中断的获取锁
- Boolean tryLock() 尝试非阻塞的获取锁
- Boolean trylock(long time,TimeUnit unit) 超时的获取锁
- void unlock() 释放锁
- Condition newCondition() 获取等待通知组件，该组件和当前的锁绑定

## 队列同步器 AbstractQueuedSynchronizer
- getState() 获取当前同步状态
- setState() 设置当前同步状态
- compareAndSetState(int except,int update) 使用CAS设置当前状态，该方法保证了状态设置的原子性

同步器可以重现的方法

- boolean tryAcquire(int arg) 独占试获取同步状态
- boolean tryRelease(int arg) 独占试释放同步状态
- int tryAcquireShared(int arg) 共享式获取同步状态，返回大于等于0的值表示获取成功
- boolean tryReleaseShared(int arg) 共享式释放同步状态
- boolean isHeldExclusively() 当前同步器是否在独占模式下被线程占用


同步器提供的模板方法

- void acquire(int arg) 
- void acquireInterruptibly(int arg)
- boolean tryAcquireNanos(int arg,long nanos)
- void acquireShared(int arg)
- void acquireSharedInterruptibly(int arg)
- boolean trayAcquireSharedNanos(int arg,long nanos)
- boolean release(int arg)
- boolean releaseShared(int arg)
- Collection<Thread> getQueuedThreads()获取等待同步队列上的线程集合

